package org.example.functionalProgramming;

import java.util.Optional;
import java.util.stream.Stream;

public class MapReduceExample {

    /*
    * Как найти из множества людей студента с самым оптимальным возрастом?
    * Если у нас нет отсортированного множетсва то мы
    * разбиваем наших студентов на группы, к приму на 3 по миллиону
    *
    * [1_000_000] -> age -> max
    *
    * [1_000_000] -> age -> max -> max
    *
    * [1_000_000] -> age -> max
    *
    * И чтобы найти этого студента разбиваем на группы наших студентов и
    * пробегаемся по каждой группе
    * Находим из каждой группы студента и сравниваем их, таким образом находим нужного студента
    * Можно разбить и на большее кол-во, но нужно больше мощностей
    *
    * */

    public void getPerfectStudent() {
        Stream.of(
                new Student(21, "Denis"),
                new Student(20, "Arina"),
                new Student(23, "Ivan"),
                new Student(40, "Sergey"),
                new Student(22, "Ilia"),
                new Student(31, "Danila"),
                new Student(64, "Nikita"),
                new Student(55, "Alisa")
        )
                /*
                * Распараллелили поток студентов
                * */
                .parallel()
                /*
                * Вычесления в одном потоке
                * */
//                .sequential()
//                Получаем возраст всех студентов
                /*
                * Filter идёт до map потому что
                * сначала необходимо отфильтровать студентов по определенному критерию (в данном случае по возрасту),
                * а затем применить операцию преобразования (в данном случае получение возраста студентов).
                * */

                /*
                * Операция filter принимает предикат (функцию, которая возвращает true или false) и применяется ко всем элементам потока,
                * оставляя только те, которые соответствуют заданному условию.
                * В данном случае, это student -> student.getAge() > 20, то есть остаются только те студенты,
                * возраст которых больше 20 лет.
                * */
//                .filter(student -> student.getAge() > 20)
                /*
                * Операция map преобразует каждый элемент потока с использованием переданной функции.
                * В данном случае, это Student::getAge,
                * то есть каждый объект Student преобразуется в значение возраста.
                * */

                /*
                * Эффективность: Фильтрация на ранних этапах уменьшает количество элементов,
                * которые будут обработаны в следующих операциях. Это снижает количество преобразований,
                * что делает процесс более эффективным.
                * Логическая последовательность: Сначала логично выбрать элементы, которые нас интересуют (например, студентов старше 20 лет),
                * а затем работать с их возрастами. Если поменять порядок операций, сначала преобразовав всех студентов в их возраст,
                * а затем фильтруя, это приведет к лишней работе и усложнит код.
                * */
                .map(Student::getAge)
                // Находим максимальный возраст
//                .reduce(Math::max)
//                Сумма всех возрастов, 0 - начальное значение
                .reduce(Integer::sum)
                // вывод
                .ifPresent(System.out::println);
    }

    public void getPerfectStudentReturnStudent() {
        /*
        * Optional работает всегда с 1 экземпляром в отличии от Stream
        * */
        Optional<Student> maybeStudent = Stream.of(
                new Student(21, "Denis"),
                new Student(20, "Arina"),
                new Student(23, "Ivan"),
                new Student(40, "Sergey"),
                new Student(22, "Ilia"),
                new Student(31, "Danila"),
                new Student(64, "Nikita"),
                new Student(55, "Alisa")
        )
                .sequential()
                /*
                * flatMap используется, когда элементы потока сами по себе являются потоками или коллекциями.
                * Этот метод позволяет преобразовать каждый элемент потока в новый поток,
                * а затем "развернуть" эти вложенные потоки в единый плоский поток.
                * */
//                .flatMap(student -> student.getMarks().stream())
//                .map(mark -> )
                .reduce(((student, student2) -> student.getAge() > student2.getAge() ? student : student2));

        maybeStudent.ifPresent(System.out::println);

        maybeStudent.map(Student::getAge)
                .map(age -> age * 5)
                .ifPresent(System.out::println);
    }

}
